// --- BEGIN: robust aes helper (replace existing aesEncrypt / init block) ---
const crypto = require('crypto');

/**
 * Normalize key/iv:
 * - trim whitespace/newlines
 * - detect hex (only 0-9a-fA-F) and convert to Buffer if so
 * - otherwise use UTF-8 bytes
 */
function normalizeKeyIv(keyStr, ivStr) {
  const k = (keyStr || '').trim();
  const iv = (ivStr || '').trim();

  const looksLikeHex = s => /^[0-9a-fA-F]+$/.test(s) && (s.length % 2 === 0);
  const keyBuf = looksLikeHex(k) ? Buffer.from(k, 'hex') : Buffer.from(k, 'utf8');
  const ivBuf  = looksLikeHex(iv) ? Buffer.from(iv, 'hex')  : Buffer.from(iv, 'utf8');

  return { keyBuf, ivBuf, rawKey: k, rawIv: iv };
}

function getAlgorithmForKeyBuffer(keyBuf) {
  if (keyBuf.length === 16) return 'aes-128-cbc';
  if (keyBuf.length === 24) return 'aes-192-cbc';
  if (keyBuf.length === 32) return 'aes-256-cbc';
  throw new Error('Unsupported key length: ' + keyBuf.length);
}

/**
 * aesEncrypt: encrypt plain text -> base64
 * - accepts key/iv as strings (hex or ascii)
 * - auto-select algorithm based on key byte length
 */
function aesEncrypt(plainText, keyStr, ivStr) {
  const { keyBuf, ivBuf } = normalizeKeyIv(keyStr, ivStr);

  // sanity checks
  if (!keyBuf || !ivBuf) throw new Error('Missing key or iv for AES encryption');
  const alg = getAlgorithmForKeyBuffer(keyBuf);

  const cipher = crypto.createCipheriv(alg, keyBuf, ivBuf);
  let out = cipher.update(String(plainText), 'utf8', 'base64');
  out += cipher.final('base64');
  return out;
}

/**
 * aesDecrypt: base64 -> utf8 (optional)
 */
function aesDecrypt(base64Text, keyStr, ivStr) {
  const { keyBuf, ivBuf } = normalizeKeyIv(keyStr, ivStr);
  const alg = getAlgorithmForKeyBuffer(keyBuf);
  const decipher = crypto.createDecipheriv(alg, keyBuf, ivBuf);
  let out = decipher.update(String(base64Text), 'base64', 'utf8');
  out += decipher.final('utf8');
  return out;
}
// export if needed
module.exports = { aesEncrypt, aesDecrypt };
// --- END: robust aes helper ---
